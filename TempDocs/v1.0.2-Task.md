## 2) Database & RLS

**UX Designerâ€™s Intent:**
The database is our **storybook spine**, but privacy rules differ depending on the content type. A guestâ€™s **RSVP and scavenger hunt progress** are personal â€” only they and the admins should see them. This creates a sense of safety: your RSVP is yours alone, and your hunt journey is private. By contrast, the **photo gallery is collective**: what you upload is meant to be shared with everyone, so guests can browse and celebrate together. Clear isolation for personal data and openness for community content ensures trust, fun, and scalability for future parties.

**Tasks:**

* [ ] **Core tables**:

  * `users` (profile data)
  * `rsvps` (isolated per user; 1 per guest)
  * `comments` (threaded guestbook, tied to user)
  * `photos` (uploads visible to all once approved)
  * `vignettes` (past story hooks)

* [ ] **Hunt tables** (private per user):

  * `hunt_hints` (master list, public-readable)
  * `hunt_runs`, `hunt_progress`, `hunt_rewards` (only owner + admin can read/write)

* [ ] **Tournament tables**:

  * `tournament_registrations` (per user/team entry)
  * `tournament_teams`, `tournament_matches`

* [ ] **Roles**:

  * `user_roles` table for admin gating.

* [ ] **RLS (Row-Level Security):**

  * **RSVPs & Hunt:** guests can only see/edit their own records; admins see all.
  * **Photos & Comments:** publicly readable; only owner can edit/delete their own; admin can moderate.

* [ ] **RPCs:**

  * `upsert_rsvp` (user saves their RSVP)
  * `register_team` (tournament entry)
  * `mark_hint_found` (scavenger hunt progress)

**AC:**

* Guests can only see/update their **own RSVP and hunt progress**.
* Gallery photos and comments are **shared for all guests to view** (after moderation).
* Admins have full visibility and management.

---

## 2) Database & RLS

**UX Designerâ€™s Intent:**
The database is our **storybook spine**, but privacy rules differ depending on the content type. A guestâ€™s **RSVP and scavenger hunt progress** are personal â€” only they and the admins should see them. This creates a sense of safety: your RSVP is yours alone, and your hunt journey is private. By contrast, the **photo gallery is collective**: what you upload is meant to be shared with everyone, so guests can browse and celebrate together. Clear isolation for personal data and openness for community content ensures trust, fun, and scalability for future parties.

**Tasks:**

* [ ] **Core tables**:

  * `users` (profile data)
  * `rsvps` (isolated per user; 1 per guest)
  * `comments` (threaded guestbook, tied to user)
  * `photos` (uploads visible to all once approved)
  * `vignettes` (past story hooks)

* [ ] **Hunt tables** (private per user):

  * `hunt_hints` (master list, public-readable)
  * `hunt_runs`, `hunt_progress`, `hunt_rewards` (only owner + admin can read/write)

* [ ] **Tournament tables**:

  * `tournament_registrations` (per user/team entry)
  * `tournament_teams`, `tournament_matches`

* [ ] **Roles**:

  * `user_roles` table for admin gating.

* [ ] **RLS (Row-Level Security):**

  * **RSVPs & Hunt:** guests can only see/edit their own records; admins see all.
  * **Photos & Comments:** publicly readable; only owner can edit/delete their own; admin can moderate.

* [ ] **RPCs:**

  * `upsert_rsvp` (user saves their RSVP)
  * `register_team` (tournament entry)
  * `mark_hint_found` (scavenger hunt progress)

**AC:**

* Guests can only see/update their **own RSVP and hunt progress**.
* Gallery photos and comments are **shared for all guests to view** (after moderation).
* Admins have full visibility and management.

---

Awesomeâ€”here are **ready-to-paste Supabase SQL snippets** that enforce exactly what you asked:

* **RSVP + Scavenger Hunt = private** (owner + admin only)
* **Gallery photos/comments = shared** (publicly readable once approved; owner/admin can manage)

Iâ€™ve included an `is_admin()` helper, RLS enablement, policies for each table, and storage rules for the gallery bucket.

---

# ğŸ” Setup: Admin role helper

```sql
-- Admin role table (if not already created)
create table if not exists public.user_roles (
  user_id uuid primary key references auth.users(id) on delete cascade,
  role text not null check (role in ('admin'))
);

-- Helper to check the current userâ€™s admin status
create or replace function public.is_admin()
returns boolean
language sql
stable
security definer
set search_path = public
as $$
  select exists(
    select 1
    from public.user_roles ur
    where ur.user_id = auth.uid() and ur.role = 'admin'
  );
$$;
```

> Seed yourself as admin once:

```sql
insert into public.user_roles (user_id, role) values ('<YOUR-USER-UUID>', 'admin')
on conflict (user_id) do update set role = excluded.role;
```

---

# ğŸ§¾ RSVPs â€” private per user (owner + admin)

```sql
-- Ensure table exists with user_id
-- create table public.rsvps (..., user_id uuid not null references auth.users(id), ...);

alter table public.rsvps enable row level security;

-- SELECT: owner or admin
create policy "rsvps_select_owner_or_admin"
on public.rsvps
for select
to authenticated
using (user_id = auth.uid() or public.is_admin());

-- INSERT: only the user (or admin on behalf of)
create policy "rsvps_insert_self_or_admin"
on public.rsvps
for insert
to authenticated
with check (
  user_id = auth.uid() or public.is_admin()
);

-- UPDATE: owner or admin
create policy "rsvps_update_owner_or_admin"
on public.rsvps
for update
to authenticated
using (user_id = auth.uid() or public.is_admin())
with check (user_id = auth.uid() or public.is_admin());

-- DELETE (optional): owner or admin
create policy "rsvps_delete_owner_or_admin"
on public.rsvps
for delete
to authenticated
using (user_id = auth.uid() or public.is_admin());
```

---

# ğŸ•µï¸ Scavenger Hunt â€” private per user (owner + admin)

```sql
-- Public list of hints everyone can read
-- create table public.hunt_hints (id bigint generated always as identity primary key, ...);
alter table public.hunt_hints enable row level security;

create policy "hunt_hints_public_read"
on public.hunt_hints
for select
to anon, authenticated
using (true);

-- Per-user progress (private)
-- create table public.hunt_runs (..., user_id uuid references auth.users(id), ...);
-- create table public.hunt_progress (..., user_id uuid references auth.users(id), hint_id bigint references public.hunt_hints(id), ...);
-- create table public.hunt_rewards (..., user_id uuid references auth.users(id), ...);

alter table public.hunt_runs enable row level security;
alter table public.hunt_progress enable row level security;
alter table public.hunt_rewards enable row level security;

-- SELECT: only the owner or admin
create policy "hunt_runs_select_owner_or_admin"
on public.hunt_runs
for select
to authenticated
using (user_id = auth.uid() or public.is_admin());

create policy "hunt_progress_select_owner_or_admin"
on public.hunt_progress
for select
to authenticated
using (user_id = auth.uid() or public.is_admin());

create policy "hunt_rewards_select_owner_or_admin"
on public.hunt_rewards
for select
to authenticated
using (user_id = auth.uid() or public.is_admin());

-- INSERT: only the owner (or admin)
create policy "hunt_runs_insert_self_or_admin"
on public.hunt_runs
for insert
to authenticated
with check (user_id = auth.uid() or public.is_admin());

create policy "hunt_progress_insert_self_or_admin"
on public.hunt_progress
for insert
to authenticated
with check (user_id = auth.uid() or public.is_admin());

create policy "hunt_rewards_insert_self_or_admin"
on public.hunt_rewards
for insert
to authenticated
with check (user_id = auth.uid() or public.is_admin());

-- UPDATE/DELETE: only the owner (or admin)
create policy "hunt_runs_update_owner_or_admin"
on public.hunt_runs
for update
to authenticated
using (user_id = auth.uid() or public.is_admin())
with check (user_id = auth.uid() or public.is_admin());

create policy "hunt_progress_update_owner_or_admin"
on public.hunt_progress
for update
to authenticated
using (user_id = auth.uid() or public.is_admin())
with check (user_id = auth.uid() or public.is_admin());

create policy "hunt_rewards_update_owner_or_admin"
on public.hunt_rewards
for update
to authenticated
using (user_id = auth.uid() or public.is_admin())
with check (user_id = auth.uid() or public.is_admin());

create policy "hunt_runs_delete_owner_or_admin"
on public.hunt_runs
for delete
to authenticated
using (user_id = auth.uid() or public.is_admin());

create policy "hunt_progress_delete_owner_or_admin"
on public.hunt_progress
for delete
to authenticated
using (user_id = auth.uid() or public.is_admin());

create policy "hunt_rewards_delete_owner_or_admin"
on public.hunt_rewards
for delete
to authenticated
using (user_id = auth.uid() or public.is_admin());
```

---

# ğŸ–¼ï¸ Gallery Photos â€” shared (publicly viewable once approved)

### Table-level (metadata & moderation)

```sql
-- Photos table for metadata & moderation
-- create table public.photos (
--   id bigint generated always as identity primary key,
--   user_id uuid not null references auth.users(id),
--   storage_path text not null,            -- e.g., 'gallery/2025/uuid-filename.jpg'
--   caption text,
--   is_approved boolean not null default false,
--   created_at timestamptz not null default now()
-- );

alter table public.photos enable row level security;

-- Public can read approved photos
create policy "photos_public_read_approved"
on public.photos
for select
to anon, authenticated
using (is_approved = true);

-- Owners & admins can see their unapproved photos too
create policy "photos_owner_or_admin_can_read_unapproved"
on public.photos
for select
to authenticated
using (user_id = auth.uid() or public.is_admin());

-- Upload (insert) by the owner (or admin on behalf)
create policy "photos_insert_owner_or_admin"
on public.photos
for insert
to authenticated
with check (user_id = auth.uid() or public.is_admin());

-- Update/Delete by owner or admin
create policy "photos_update_owner_or_admin"
on public.photos
for update
to authenticated
using (user_id = auth.uid() or public.is_admin())
with check (user_id = auth.uid() or public.is_admin());

create policy "photos_delete_owner_or_admin"
on public.photos
for delete
to authenticated
using (user_id = auth.uid() or public.is_admin());
```

### Storage bucket (`gallery`) policies

> Supabase storage reads happen through `storage.objects`. Weâ€™ll make **public read for the `gallery` bucket** (so approved items are viewable via URLs), and **owner/admin write**. Youâ€™ll gate â€œapprovedâ€ visibility via the **`photos.is_approved`** table when listing. (Public URLs remain accessible if someone has the link; approval controls listing.)

```sql
-- Create bucket (run in Dashboard Storage UI or via SQL rpc)
-- select storage.create_bucket('gallery', public => true);

-- Storage RLS (applies when you enable policies in Storage settings)
-- Public READ from gallery
create policy "storage_gallery_public_read"
on storage.objects
for select
to anon, authenticated
using (bucket_id = 'gallery');

-- Uploads only by authenticated users, limit to gallery
create policy "storage_gallery_user_insert"
on storage.objects
for insert
to authenticated
with check (bucket_id = 'gallery' and owner = auth.uid());

-- Update/Delete by owner or admin
create policy "storage_gallery_update_owner_or_admin"
on storage.objects
for update
to authenticated
using (bucket_id = 'gallery' and (owner = auth.uid() or public.is_admin()))
with check (bucket_id = 'gallery' and (owner = auth.uid() or public.is_admin()));

create policy "storage_gallery_delete_owner_or_admin"
on storage.objects
for delete
to authenticated
using (bucket_id = 'gallery' and (owner = auth.uid() or public.is_admin()));
```

> **Moderation flow:** Upload creates a `photos` row with `is_approved = false`. Admin toggles to `true` in the Admin UI. Public listing queries only `where is_approved = true`. (The storage object may be technically reachable if someone had the direct URL; the UI wonâ€™t surface it until approved.)

---

# ğŸ’¬ Comments / Guestbook â€” shared (publicly readable)

```sql
-- create table public.comments (
--   id bigint generated always as identity primary key,
--   user_id uuid not null references auth.users(id),
--   body text not null,
--   is_approved boolean not null default true, -- or false if you want pre-moderation
--   created_at timestamptz not null default now()
-- );

alter table public.comments enable row level security;

-- Public can read approved comments
create policy "comments_public_read_approved"
on public.comments
for select
to anon, authenticated
using (is_approved = true);

-- Owner/admin can read their own unapproved comments
create policy "comments_owner_or_admin_read_unapproved"
on public.comments
for select
to authenticated
using (user_id = auth.uid() or public.is_admin());

-- Insert by the author (or admin on behalf)
create policy "comments_insert_owner_or_admin"
on public.comments
for insert
to authenticated
with check (user_id = auth.uid() or public.is_admin());

-- Update/Delete by owner or admin
create policy "comments_update_owner_or_admin"
on public.comments
for update
to authenticated
using (user_id = auth.uid() or public.is_admin())
with check (user_id = auth.uid() or public.is_admin());

create policy "comments_delete_owner_or_admin"
on public.comments
for delete
to authenticated
using (user_id = auth.uid() or public.is_admin());
```

---

# ğŸ“ Tournament tables (suggested defaults)

> Not strictly requested, but hereâ€™s a sensible default: **everyone can view** tournament registrations/teams (itâ€™s fun/hype), while only **owner/admin** can modify.

```sql
-- registrations, teams, matches tables assumed with user_id on registrations

alter table public.tournament_registrations enable row level security;
alter table public.tournament_teams enable row level security;
alter table public.tournament_matches enable row level security;

-- Public/guest read for hype (or restrict to authenticated if you prefer)
create policy "tourny_regs_public_read"
on public.tournament_registrations
for select
to anon, authenticated
using (true);

-- Insert registration by the user (or admin)
create policy "tourny_regs_insert_owner_or_admin"
on public.tournament_registrations
for insert
to authenticated
with check (user_id = auth.uid() or public.is_admin());

-- Update/Delete: owner or admin
create policy "tourny_regs_update_owner_or_admin"
on public.tournament_registrations
for update
to authenticated
using (user_id = auth.uid() or public.is_admin())
with check (user_id = auth.uid() or public.is_admin());

create policy "tourny_regs_delete_owner_or_admin"
on public.tournament_registrations
for delete
to authenticated
using (user_id = auth.uid() or public.is_admin());

-- Teams & matches: admin-managed (read public, write admin)
create policy "tourny_teams_public_read"
on public.tournament_teams
for select
to anon, authenticated
using (true);

create policy "tourny_matches_public_read"
on public.tournament_matches
for select
to anon, authenticated
using (true);

create policy "tourny_teams_admin_write"
on public.tournament_teams
for all
to authenticated
using (public.is_admin())
with check (public.is_admin());

create policy "tourny_matches_admin_write"
on public.tournament_matches
for all
to authenticated
using (public.is_admin())
with check (public.is_admin());
```

---

# ğŸ§° (Optional) RPC hardening

If youâ€™re using RPCs, set them **SECURITY DEFINER** and check `is_admin()` where appropriate:

```sql
-- Example: list all RSVPs for admin table
create or replace function public.list_rsvps_admin()
returns setof public.rsvps
language sql
stable
security definer
set search_path = public
as $$
  select * from public.rsvps
  where public.is_admin();
$$;

-- Example: upsert_rsvp that forces user_id = auth.uid()
create or replace function public.upsert_rsvp(
  p_attending boolean,
  p_guests int,
  p_notes text
) returns public.rsvps
language plpgsql
security definer
set search_path = public
as $$
declare
  v_user uuid := auth.uid();
  v_row public.rsvps;
begin
  insert into public.rsvps (user_id, attending, guests, notes)
  values (v_user, p_attending, p_guests, p_notes)
  on conflict (user_id) do update
    set attending = excluded.attending,
        guests    = excluded.guests,
        notes     = excluded.notes
  returning * into v_row;
  return v_row;
end;
$$;
```

---

## âœ… Quick Acceptance Checklist (matches your intent)

* **RSVP + Hunt**: only owner and admin can read/write.
* **Gallery (photos/comments)**: **publicly readable** when approved; owner/admin can manage; unapproved visible to owner/admin only.
* **Storage**: gallery bucket is public-read, owner/admin write.
* **Admin**: global bypass via `is_admin()`.

Hereâ€™s a **ready-to-paste Lovable prompt** that asks it to generate the rune images with the pulsing/low-light animation behavior you described, and ties it directly into the **Scavenger Hunt mechanic** (15 hints, progress, reward modal). Iâ€™ve pulled in your scavenger hunt docsso the prompt is consistent.

---

# âœ… Lovable Prompt â€” â€œScavenger Hunt Rune Hints (Pulsing, Low-Light)â€

You are Lovableâ€™s lead engineer. Replace the current scavenger hunt **hint circles** with **rune images** that have transparent backgrounds and animate with a subtle pulse.

## ğŸ¨ Design Intent

* Instead of obvious glowing circles, each hint is a **subtle rune glyph** (storybook/fairytale style).
* **Pulse behavior:**

  * Very low-light glow (opacity 0.2â€“0.4).
  * Fade/pulse in for \~1.5s, then stay visible \~1s.
  * Fade out completely, then remain **off for 4â€“5s** before the cycle repeats.
* Goal: They should feel *whispered into existence*, guiding but not distracting.
* Runes must be **transparent PNG/SVG assets** so they blend with backgrounds.

## ğŸ› ï¸ Implementation

1. **Assets:**

   * Generate 15 rune images (PNG or SVG, transparent background).
   * Style: twisted fairytale / occult runes, light bone-white glow with faint green tint.
   * Dimensions: \~64Ã—64 px (scalable to 96Ã—96).

2. **Component:**

   * `HuntRune.tsx` in `src/components/hunt/`.
   * Props: `hintKey`, `onFound`.
   * Render rune image with **Framer Motion pulse animation**:

     ```tsx
     <motion.img
       src={`/img/runes/${hintKey}.png`}
       alt=""
       className="hunt-rune absolute"
       initial={{ opacity: 0 }}
       animate={{
         opacity: [0, 0.3, 0],
         transition: { duration: 1.5, repeat: Infinity, repeatDelay: 4.5 }
       }}
     />
     ```
   * Click/hover/focus triggers `onFound(hintKey)` and reveals the text hint.

3. **Placement:**

   * Follow hunt placement spec:

     * Hero (3â€“4 runes in tagline area).
     * Between sections (Costumes, Feast, Vignettes).
     * Footer/background (2â€“3).

4. **Progress & Reward:**

   * Persist progress (localStorage or Supabase, per current config).
   * When all 15 found â†’ open `HuntRewardModal` with one of the reward messages from `/data/rewards.ts`.

## âœ¨ Acceptance Criteria

* [ ] Rune assets exist in `/public/img/runes/` (15 unique).
* [ ] Each rune pulses subtly; off 4â€“5s between pulses.
* [ ] Users can hover/click/focus to collect a rune â†’ hint text shows.
* [ ] Keyboard users can tab to rune hotspots (a11y).
* [ ] Finding all 15 unlocks Easter Egg modal (randomized creepy/funny text).
* [ ] Performance: runes animate at 60fps without jank.


